# 秒杀
秒杀的本质是高性能、高一致、高可用的三高系统。

## 高性能
### 动静分离
在秒杀场景的下，只有倒计时在动,其他的都是静态页面,即数据意义上的动静分离。动静分离分三步:数据拆分、静态缓存、数据整合。

#### 数据拆分
动静分离的首要目的是将动态页面改造成适合缓存的静态页面。
>* 用户。 用户身份信息包括登录状态以及登录画像等，相关要素可以单独拆分出来，通过动态请求进行获取；与之相关的广平推荐，如用户偏好、地域偏好等，同样可以通过异步方式进行加载
>* 时间。 秒杀时间是由服务端统一管控的，可以通过动态请求进行获取。

#### 静态缓存
静态化改造的一个特点是直接缓存整个 HTTP 连接而不是仅仅缓存静态数据。
静态数据缓存到哪里呢？可以有三种方式：1、浏览器；2、CDN(二级缓存) ；3、服务端。

####  数据整合
>* ESI 方案： Web 代理服务器上请求动态数据，并将动态数据插入到静态页面中，用户看到页面时已经是一个完整的页面。这种方式对服务端性能要求高，但用户体验较好。
>* CSI 方案： Web 代理服务器上只返回静态页面，前端单独发起一个异步 JS 请求动态数据。这种方式对服务端性能友好，但用户体验稍差。


动静分离对于性能的提升，抽象起来只有两点，一是数据要尽量少，以便减少没必要的请求，二是路径要尽量短，以便提高单次请求的效率。具体方法其实就是基于这个大方向进行的。


## 限流
RateLimiter:稳定模式:稳定产生令牌速率;渐进模式:指数增长创建令牌。


## 异步编程
同时获取多种数据:


## 参考文献
[经验：一个秒杀系统的设计思考](https://mp.weixin.qq.com/s/4LYl2j-HmpiA0KYYvsgZCA)
[Spring Boot 项目的 API 接口防刷](https://mp.weixin.qq.com/s/k7h8Q1OMG2xcz7zwoI2giw)


## 问题
（1）HashMap和HashTable的区别，及其实现原理。ArrayList,LinkedList 和Vector的区别和实现原理。TreeMap和TreeSet区别和实现原理。ConcurrentHashMap实现原理（锁分离技术）。
（2）问jvm内存分代机制（会问分为那几个代，各个代特点），分代回收的优点（这个问了很多次）。
（3）String和StringBuffer,StringBuilder区别和联系，String为啥不可变，在内存中的具体形态。

（4）java中多线程机制，实现多线程的两种方式（继承Thread类和实现Runnable接口）的区别和联系。
（5）java线程阻塞调用wait函数和sleep区别和联系，还有函数yield，notify等的作用。
（6）java中的同步机制，synchronized关键字，锁（重入锁）机制，其他解决同步的方volatile关键字ThreadLocal类的实现原理要懂。

（7）java中异常机制。
（8）comparable接口和comparator接口实现比较的区别和用法，Arrays静态类如下实现排序的。