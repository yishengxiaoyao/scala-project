# 缓存和数据库不一致解决方案

## 先删除数据导致不一致
原因:先修改数据库,再删除缓存,如果删除缓存失败了,那么会导致数据库中是新数据,缓存中是旧数据,数据出现不一致
解决思路:先删除缓存,再修改数据库,如果删除缓存成功了,修改数据库失败了,那么数据库中是旧数据,缓存中是空的,那么数据不会不一致,因为读的时候缓存没有,
则读数据库中旧数据,然后更新到缓存中。

## 事件发生时机不同导致不一致
更新缓存的操作步骤:1.删除缓存;2.更新DB;3.更新缓存。如果在删除缓存之后,更新DB之前,发生请求,就会导致DB和缓存的数据不一致。
在并发量低的情况话,不会出现这种情况,在并发量高的情况下,就会出现上面说的这种情况。

## 数据库与缓存更新与读取操作进行异步串行化
异步串行化就是将异步任务串行执行,就是保证执行删除缓存,更新DB,更新缓存顺序,在这期间不会有其他请求执行。

具体流程如下:
>* 更新数据的时候，根据数据的唯一标识，将操作路由之后，发送到一个 jvm 内部的队列中
>* 读取数据的时候，如果发现数据不在缓存中，那么将重新读取数据+更新缓存的操作，根据唯一标识路由之后，也发送同一个 jvm 内部的队列中
>* 一个队列对应一个工作线程，每个工作线程串行拿到对应的操作，然后一条一条的执行。

多个删除缓存、更新DB、更新缓存的请求串行化,有可能会导致后面的请求超时。

需要判断有没有缓存,如果没有缓存,循环查询,如果超时,返回旧值。

可优化的点:
>* 一个队列中,其实多个更新缓存请求串在一起是没意义:如果发现队列中已经有一个更新缓存的请求了，那么就不用再放个更新请求操作进去了，直接等待前面的更新操作请求完成即可。
>* 缓存为空，有可能不是在更新操作:缓存过期,还没有更新缓存;也有可能不存在相应数据。

## 如何提升命中率
分发层 Nginx，负责流量分发的逻辑和策略，这个里面它可以根据你自己定义的一些规则， 比如根据 productId 去进行 hash，然后对后端的 Nginx 数量取模，
将某一个商品的访问的请求,就固定路由到一个 Nginx 后端服务器上去，保证说只会从 Redis 中获取一次缓存数据， 后面全都是走 Nginx 本地缓存了

后端的 Nginx 服务器，就称之为应用服务器; 最前端的 Nginx 服务器，被称之为分发服务器。





