# 高并发系统设计的基础
## 高并发系统
应对高并发的方法:
>* Scale-out(横向扩展):分而治之是一种常见的高并发系统设计方法,采用分布式部署的方式把流量分流开,让每个服务器都承担一部分并发和流量。
>* 缓存:使用缓存来提高系统的性能。
>* 异步:未处理完成之前我们可以让请求先返回,在数据转背好之后再通知请求方,这样可以在单位时间内处理更多的请求。

如何选择scale-out与scale-up?
使用堆砌硬件解决的问题就用硬件来解决,使用scale-out方式,如果系统并发超过单机的极限时,就用scale-out.

为什么缓存可以大幅度提升系统的性能?
数据一般都是持久化到磁盘上。普通磁盘数据是由机械手臂、刺头、转轴、磁盘组成，磁盘有分为磁道、柱面和扇区。
扇区是存储介质，每个磁盘被划分为多个同心圆,信息存储在同心圆之中,这些同心圆就是磁道。磁头寻找信息话费的时间叫做寻道时间。
普通磁盘的寻道时间是10ms左右，在整个计算机体系中磁盘是最慢的一环,使用内存作为存储介质的缓存,以提升性能。

## 为什么要分层
分层的设计的好处:
>* 简化系统设计，让不同的人专注做某一层次的事情。
>* 分层之后可以做到很高的复用。
>* 最后一次,分层架构可以让我们更容易做横向扩展。

分层架构中每一层的作用:
>* 终端显示层:各端模块渲染并执行显示的层。当权主要是velocity渲染、js渲染、jsp渲染、移动端显示等。
>* 开放接口层:将service层方法封装成开放接口,同时进行网关安全控制和流量控制等。
>* web层:主要对访问控制进行转发,各类基本参数校验,或者不复用的业务简单处理等。
>* service层:业务逻辑层
>* Manager层:通用业务护理层。
>* DAO层:数据访问层。

分层架构的不足:
>* 在接收到请求是可以直接访问DB获取结果,却偏偏要在中间插入多个层次,并且有可能每个层次只是简单地做数据的传递;小需求开发,成本高。
>* 每个层次独立部署,层次间通过网络交互,多层次的架构在性能上有消耗。

## 系统设计目标
### 如何设计系统性能
高并发系统设计的三大目标:高性能、高可用、可扩展。
高并发是值运用设计手段让系统能够处理更多的用护并发请求，也就是承担更大的流量。

性能优化原则:
>* 性能优化一定不能盲目,一定是问题导向的。
>* 性能优化也遵循八二原则。
>* 性能优化也要有数据支撑。
>* 性能优化的过程是持续的。

性能的度量指标:
>* 平均值:把这段时间所有的请求相应时间数据相加,在除以总请求数。　
>* 最大值:这段时间内所有请求响应时间最长的值。
>* 分位值:落在响应时间的值占用的比重。

高并发下的性能优化:
>* 提高系统的处理核心数(吞吐量=核心数(并发进程数)/响应时间)
>* 减少单次任务线响应时间(根据类型不同选择不同的处理方法)
>   * 调用非阻塞的rpc调用
>   * 将计算密集型和和IO密集型的逻辑分割开,单独线程池,调整线程比例压榨单机性能
>   * 使用缓存,减少读取的时间
>   * 采用享元模式,用好对象池和本地线程空间,尽量减少对象黄建与销毁的开销,提高复用。
>   * 业务拆分:可以借助中间件做一些处理。
>   * fork/join:对线程处理
>   * 数据库撇值优化，查询优化。
### 系统如何做到高可用
#### 可用性的度量

可用性的度量包含MTBF和MTTR。

MTBF(Mean Time Between Failure)是平均故障间隔的问题,代表两次故障的间隔时间,这个时间越长,系统稳定性越高。
MTTR(Mean Time To Repair)表示故障的平均恢复时间。

Availibity = MTBF/(MTBF+MTTR)

#### 高可用系统设计的思路
1.系统设计:故障转移(对等节点之间转移、不对等节点之间的转移)、降级(为了保证核心服务的稳定而牺牲非核心服务的做法)、限流。

2.系统运维:灰度发布(按照比例逐渐发布新版本服务)、故障演练。

### 如何让系统更易于扩展

拆分是提升系统扩展性最重要的一个思路,把庞杂的系统拆分成独立的,由单一指责的模块。

## 数据库优化方案

主从读写分离的技术关键点:1.数据的拷贝,成为主从复制;2.主从分离的情况下,如何屏蔽主从分离带来的访问数据方式的变化。

主从复制,如果存在数据延迟,就会导致数据不一致,解决方案:
>* 数据的冗余。将全部数据发给下游。
>* 使用缓存。将数据写入数据库的时候,也将数据写入缓存。
>* 查询主库。

直播项目:
>* 垂直拆分:对数据库竖着拆分,也就是将数据库的表拆分到多个不同的数据库中。
>* 水平拆分:将单一数据表按照一定规则拆分到多个数据和多个数据表中,关注点在数据上。


## NoSQL
对于机械磁盘的访问方式有两种:一种是随机IO,另一种是顺序IO。
很多NoSQL数据库都在使用基于LSM树的存储引擎。
LSM树牺牲了一定的读性能来换取写入数据的高性能。

LSM的思想:
>* 数据首先会写入到一个叫做MemTable的内存结构中,在MemTable中数据是按照写入的key来排序的,为了方式MemTable里面因为机器掉电或者重启而丢失的,
>   一般会通过写入Write AHead Log的方式将数据备份在磁盘上。
>* MemTable在累计到一定规模时,它会刷新生成一个新的文件,这个文件叫SSTable,当SSTable达到一定数量后,会将SSTable合并,减少文件的数量,因为
>   SSTable是有序的,所以合并的速度也很快。
>* 当从LSM树里面读取数据时,首先从MemTable中查找数据,如果数据没有找到,再从SSTable中查找数据。因为存储的数据都是有序的,所以查找的效率是很高的
>   只是因为数据被拆分为多个SSTable,所以读取的效率会低于B+树索引。


MongoDB扩展方面的特性:
>* Replica:副本集,可以理解为主从分离,也就是通过将数据拷贝成多份来保证当主挂掉后数据不会丢失。Replica还可以分担读请求,
>   并且把数据变动记录到oplog里(类似于binlog);从节点接收到oplog后会修改滋生的数据以保持和主节点的一致。一旦主节点挂了,MongoDB
>   会选择一个节点作为主节点,可以记录提供写数据服务。
>* Shard:分片,将数据按照某种规则拆分成多份,存储在不同的机器上。Shard Server是实际存储数据的节点,是一个独立的MongoDB进程;
>   Config Server是一组MongoDB进程,主要存储一些元消息;Route Server:仅仅作为路由使用，从Config Server中获取元信息后,
>   将请求路由到正确的Shard Server中。
>* 负载均衡:当数据分布不均匀的时候,会启动Balancer进程对数据做重新的分配, 最终让不同的Shard Server的数据可以尽量均衡。


