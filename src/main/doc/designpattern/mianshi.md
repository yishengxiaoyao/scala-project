# 问题总结(中华石衫)
https://www.bilibili.com/video/av94222148

## HashMap
JDK7的时候，HashMap的底层实现为数组+链表(Entry)

JDK8的时候，HashMap的底层实现为数组+链表+红黑树(Node)

为了将数据分布均匀,需要计算出元素的hash值,确定在数组的位置，然后在链表中进行操作

在计算hash值的时候,将元素的hashcode的前16为与后16为进行异或操作,这样这个值就可以拥有前后16位的特征,在与数组的操作过程中,
就会减少hash碰撞,提高效率。位运算的效率高

寻址算法的优化:
>* hash % n  = (n-1) & hash 因为位操作的性能高于 % 的操作,% 操作也会转换为位运算
>* 如果n不是2的幂次,这样就会造成数据的分布不均匀,造成元素之间的碰撞,效率降低。

## ConcurrentHashMap

JDK7 Segment implement ReentrantLock 头查法
 
JDK8 Segment synchronized cas 尾插法


## 线程池

在远程服务异常的情况下,使用无界阻塞队列,是否会导致内存飙升?

调用超时,队列变得越来越大,此时会导致内存飙升起来,而且可能导致OOM


如果线程池的队列满了之后,会发生什么？

如果队列是有界队列,可以防止内存溢出(OOM);如果最大线程数没有达到最大值,可以创建线程,处理任务;
如果线程数没有限制，导致内存、CPU负载高;如果线程数达到最大线程数之后,再有任务请求过来之后,就会执行拒绝策略:
AbortPolicy:抛出异常(默认);DiscardPolicy:丢弃任务;DiscardOldestPolicy:丢弃第一个任务;CallerRunPolicy:
创建用户线程来执行任务。

如果队列是无界队列,会导致内存溢出;


线上服务器宕机,线程池中的阻塞队列中的请求怎么办？

必然会导致线程池里的挤压的任务丢失,将要提交的任务存储到一个DB中,记录任务的状态,更新状态:未提交、已提交、已完成。
提交成功之后,更新状态。
系统重启之后，扫描DB中未提交和已提交的任务,让任务信息读取出来,重新提交到线程池中,继续执行。



## Redis
### RDB优点
1.RDB会生成多个数据文件,每个数据文件都代表了某一个时刻redis的全部数据,这种方式适合冷备。

2.RDB对Redis对外提供的读写服务,影响非常小,可以让redis保持高性能。RDB直接写入内存，如果量达到一定程度之后,写入磁盘，AOF直接写入磁盘

3.基于RDB数据文件来重启和恢复redis进程,更加快速。AOF存储的指令日志,RDB直接存储的数据


### RDB缺点
RDB有可能丢失的数据比较多(根据时间间隔来判断);如果数据量大,可能会导致卡顿;


### AOF优点
1.AOF可以更好的保护数据不丢失,每秒执行一次写操作;

2.AOF文件以append-only模式写入,写入性能高,没有任何磁盘寻址的开销。

3.AOF日志文件即使过大的时候,出现重写操作,不影响客户端的读写。

### AOF缺点
同一分数据,AOF日志文件通常比RDB大。


### 缓存DB一致
先删除缓存在写DB  如果缓存需要复杂逻辑计算出来,容器超时,在下次情况的时候在进行计算;有可能访问频率没有这么高,在下次访问的时候再计算。


先写DB，然后在删除缓存:在删除缓存的时候，出现异常,造成DB与缓存不一致。


并发读写不一致: 先删除缓存,更新DB,将这些串行化,如果多个相同的请求的话，将他们直接一次处理。

