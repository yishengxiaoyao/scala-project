# 弹力设计

## 认识故障和弹力设计
### 系统可用性测量
可用性 = MTTF/(MTTF+MTTR)
MTTF平均故障前的时间，即系统平均能够正常运行多长时间才发生一次故障(正常运行的时间)。
MTTR平均修复时间，即从故障出现到故障修复的这段时间。

### 故障分类
无计划的宕机:
>* 系统故障,包括主机、操作系统、中间件、数据库、网络、电源以及外围设备。
>* 数据和中介的故障，包括人员误操作、硬盘故障、数据乱了。
>* 自然灾害、人为破坏，以及供电问题等。

有计划的宕机:
>* 日常任务:备份，容量规划，用户和安全管理，后台批处理应用。
>* 运维相关:数据库维护、应用维护、中间件维护、操作系统维护、网络维护。
>* 升级相关:数据库、应用、中间件、操作系统、网络，包括硬件升级。

## 隔离设计

系统的隔离分为两种:以服务的种类来做分离；以用户来做分离。

### 按服务的种类来做分离



### 按照用户来做分离

多租户的做法:
>* 完全独立的设计。每个租户有自己完全独立的服务和数据。
>* 独立的数据分区，共享的服务。多组合的服务是共享的，但数据是分开隔离的。
>* 共享的服务，共享的数据分区。每个租户的数据和服务都是共享的。

| |完全独立资源|共享的服务接口<br/>独立的数据分区|共享的服务接口<br/>共享的数据分区|
|----|----|----|----|
|资源共享度|低|中|高|
|实现复杂度|低|中|高|
|隔离度|高|中|低|
|占用成本度|高|中|低|

## 异步通讯设计
### 同步调用
同步调度虽然让系统只耦合与接口，而且实时性也会比异步调用要高，但仍有问题:
>* 同步调用需要被调用方的吞吐不低于调用方的吞吐。
>* 同步调用会导致调用方一直在等待被调用方完成。
>* 同步调用只能是1对1。
>* 同步调用最不好的是，如果被调用方有问题，那么其他调用方就会跟着出问题。

### 异步调用
异步调用三种方式:请求响应式、通过订阅的方式、通过broker的方式。

请求调用式:发送方会直接请求接收方，被请求方接收到请求会，直接返回一一收到请求，正在处理。

通过订阅的方式:接收方会来订阅发送方的消息，发送方会把相关的信息或数据放到接收方所订阅的队列中，而接收方会从队列中红获取数据。

通过broker的方式:发送方和接收方都相互看不到对方，他们看得到的是一个broker，发送方向broker发送消息，接收方向broker订阅消息(完全的解耦)。

broker必须要有如下属性:
>* 必须是高可用，因为它成了整个系统的关键。
>* 必须是高性能而且是可以水平扩展的。
>* 必须是可以持久化不丢数据。

### 事件驱动设计
事件驱动设计的好处:
>* 服务间的依赖没有了，服务件是平等的，每个服务都是高度可重用并可被替换的。
>* 服务的开发、测试、运维，以及故障处理都是高度隔离的。
>* 服务间通过事件关联，所以服务间是不会相互block的。
>* 在服务间增加一些adapter相当容易。
>* 服务间的吞吐也被解开了，各个服务可以按照自己的处理速度处理。

事件驱动设计的缺点:
>* 业务流程不在那么明显和好管理。
>* 事件可能会乱序。
>* 事件处理变得复杂。

### 为什么要异步通讯

使用异步通讯的原因:
>* 异步通讯最重要的是解耦服务间的依赖。最佳解耦的方式是通过broker的机制。
>* 解耦的目的是让各个服务的隔离性更好。
>* 异步通讯的架构可以获得更大的吞吐量，而且各个服务之间的性能不受干扰相对独立。
>* 利用broker或者队列的方式还可以达到把都懂的吞吐量编程均匀的吞吐量。
>* 服务相对独立，在部署、扩容和运维上都可以做到独立不受其他服务的干扰。

使用异步通讯的时候，需要注意如下事宜:
>* 用于异步通信的中间件broker成为关键，需要设计成高可用不丢消息。因为是分布式，很难保证消息的顺序，设计最好不依赖于消息的顺序。
>* 异步通讯会导致业务处理流程不那么直观。
>* 服务间只通过消息交互，所以业务状态最后有一个总控方管理，这个总控方维护一个业务流程的状态变迁逻辑，以便系统发生故障后知道业务处理到哪一步。
>* 消息传递中，可能有的业务逻辑会有像TCP协议那样的send和ACK机制。

## 幂等性设计

幂等性:一次和多次请求某一个资源应该具有同样的副作用。

Snowflake是一个分布式ID的生成算法。其核心思想是，产生一个long型的ID，其中:
>* 41bits作为毫秒数，大概可以用69.7年。
>* 10bits作为机器编号(5bits是数据中心，5bits的机器ID)，支持1024个实例。
>* 12bits作为毫秒内的序列号，一秒可以生成4096个序号。
### HTTP幂等性

HTTP GET、OPTION、HEAD、DELETE都满足幂等性。

HTTP POST、PUT方法用于创建资源、修改资源，有副作用，不满足幂等性。

幂等性的设计如下:
>* 表单中需要隐藏一个token，这个token可以是前端生成的一个唯一的ID。用于方式用户多次点击了表单提交按钮，
而导致后端收到了多少请求，却不能分辨是否是重复的提交。这个token是表单的唯一标识。
>* 用户点击提交后，后端会把用户提示的数据和这个token保存在数据库中。如果有重复提交，那么数据库中的token会做
排它限制，从而做到幂等性。
>* 后端成功前端返回302跳转，把用户的前端页跳转到GET请求，把刚刚POST的数据给展示出来。

## 服务的状态
所谓状态就是为了保留程序的一些数据或者上下文。

有状态的服务有哪些好处:
>* 数据本地化:状态和数据是本机保存，这样可以有更低的延迟。
>* 更高的可用性和更强的一致性:CAP原理中的A和C。

对于有状态的服务，必需保证其落在同一个实例中，这叫sticky session，这样不需要考虑数据要被加载到不同的节点上去。

无状态的服务需要把数据同步到不同的节点上，而有状态的服务通过sticky session做数据分片。

Sticky Session的实现:
>* 持久化的长连接。HTTP协议也要用长连接。通过一个简单的哈希算法，这样节点的负载和数据并不会很均匀。如果做到负载和数据均匀的话，需要有一个元数据索引来
映射后端服务实例和请求的对应关系，还需要一个路由节点，这个路由节点会根据元数据索引来路由，而这个元数据索引表会根据后端服务的压力来重新组织相关的映射。
如果去掉路由节点，可以直接使用配置，节点启动时把其元数据读到内存中，如果出现增加或者减少节点都需要更新这个配置。
另外一种是Gossip协议，通过这个协议在各个节点之间互相散播消息来同步元数据，这样增加或者减少节点，集群内部可以很容器重新分配。


## 服务状态
### 什么是状态
状态：保留程序的一些数据或是上下文：

* 程序调用的结果。
* 服务组合下的上下文。
* 服务的配置。
### 服务状态类型
1.无状态的服务
* 可以随意扩展或删除节点
* 依赖第三方储存系统以及自身构建缓存，第三方存储系统：
    * Redis
    * MySQL
* 高可用强一直：ZK/Etcd
* 依赖有状态存储服务，存在网络开销；自身构建缓存浪费资源

2.有状态的服务
* 数据本地化（Data Locality），延时低
* 更高的可用性和更强的一致性
* 特点：请求映射到同一个节点， 出现：Sticky Session 或是 Sticky Connection
* 如何实现Sticky Connection
    * 长链接或一致性hash，出现服务热点问题
    * 做到负载和数据均匀方案
    * 路由节点
    * 元数据索引：映射后端服务实例和请求的对应关系表
    * 路由结点：根据元数据索引来路由，而这个元数据索引表会根据后端服务的压力来重新组织相关的映射
    * 直连，不好动态扩展
    * Gossip 协议，广播节点信息同步元数据
* 案例：Facebook 的 Scuba、 Orleans
* 资料：《Making the Case for Building Scalable Stateful Services in the Modern Era》

3. 有无状态服务的对比
无状态的服务需要我们把数据同步到不同的结点上，而有状态的服务通过 Sticky Session 做数据分片（当然，同步有同步的问题，分片也有分片的问题，这两者没有谁比谁好，都有 trade-off）。

## 补偿事物

### ACID(强一致性CAP中的P)
>* 原子性:整个事务的所有操作，要么全部完成，要么全部失败，不可能停滞在中间某个环节。事务在执行过程中发生错误，会被回滚到事务开始的状态，就像这个事务从来没有执行过一样。
>* 一致性:在事务开始之前和事务结束以后，数据库的玩横行约束没有被破坏。
>* 隔离性:两个事务的执行是互补干扰的，一个事务不可能看到其他事务运行时中间某一时刻的数据，两个事务不会发生交互。
>* 持久性:事务完成后，该事务对数据库所做的更改便持久地保存在数据库之中，并不会被回滚。

### BASE(CAP中的A，很好的伸缩性)
>* Basic Availability:基本可用,系统可以出现暂时不可用的状态，而后面会快速恢复。
>* Soft-state:然状态，为了提高性能，可以让服务暂时保存一些状态或数据，这些数据和状态不是强一致性。
>* Eventual Consistency:最终一致性，系统在一个短暂的时间段内是不一致的，但最终整个系统看到的数据是一直。

### 业务补偿的设计重点
>* 因为要把一个业务流程执行完毕，需要这个流程中所设计的服务方支持幂等性。并且在上游有重试机制。
>* 前往不要把这些状态放到不同的组件中，最好是一个业务流程的控制方来做这个事，也就是一个工作流引擎。
>* 补偿的业务逻辑和流程不一定非得是严格反向操作。
>* 业务补偿的业务逻辑是强业务相关的，很难做成通用的。
>* 下层的业务方最好提供短期的资源预留机制。


## 重试设计
重试的语义是认为故障是暂时的，而不是永久的，所以，我们会去重试。

在重试的设计中，引入Exponential BackOff策略，每次重试所需要的休息时间都会成倍增加。

Spring 的重试策略(@Retryable注解):
>* NeverRetryPolicy:只允许调用RetryCallback一次，不允许重试。
>* AlwaysRetryPolicy:允许无限重试，直到成功，此方式逻辑不当会导致死循环。
>* SimpleRetryPolicy:固定次数重试策略，默认重试最大次数为3次，RetryTemplate默认使用的策略。
>* CircuitBreakerRetryPolicy:有熔断功能的重试策略，需设计3个参数opentimeout、resettimeout和delegate。
>* CompositeRetryPolicy:组合重试策略。有两种组合方式:乐观组合重试策略是指只要有一个策略允许重试即可以，悲观组合重试策略是指只要有一个策略不允许重试即不可以。
不管那种组合方式，组合中的每一个策略都会执行。

关于 Backoff 的策略如下。
>* NoBackOffPolicy：无退避算法策略，即当重试时是立即重试；
>* FixedBackOffPolicy：固定时间的退避策略，需设置参数 sleeper 和 backOffPeriod，sleeper 指定等待策略，默认是 Thread.sleep，即线程休眠，backOffPeriod 指定休眠时间，默认 1 秒。
>* UniformRandomBackOffPolicy：随机时间退避策略，需设置 sleeper、minBackOffPeriod 和 maxBackOffPeriod。该策略在 [minBackOffPeriod, maxBackOffPeriod] 之间取一个随机休眠时间，minBackOffPeriod 默认为 500 毫秒，maxBackOffPeriod 默认为 1500 毫秒。
>* ExponentialBackOffPolicy：指数退避策略，需设置参数 sleeper、initialInterval、maxInterval 和 multiplier。initialInterval 指定初始休眠时间，默认为 100 毫秒。maxInterval 指定最大休眠时间，默认为 30 秒。multiplier 指定乘数，即下一次休眠时间为当前休眠时间 *multiplier。
>* ExponentialRandomBackOffPolicy：随机指数退避策略，引入随机乘数，之前说过固定乘数可能会引起很多服务同时重试导致 DDos，使用随机休眠时间来避免这种情况。

## 熔断设计

熔断器的状态:
>* 有失败计数器，如果最近失败次数超过了在给定时间内允许失败的与之，则切换到断块状态。此时开启一个超时时钟，当该时钟超过了该时间，则切换为半断开状态。
该超时时间的设定是给了系统一次机会来修正导致失败的错误，以回到正常工作的状态。在Closed状态下，错误计数器是基于时间的。在特定的时间间隔内会自动重置。这能够防止由于
某次的偶然错误导致熔断器进入断开状态。也可以基于连续失败的次数。
>* 断开状态:对应用程序的请求会立即返回错误响应，而不调用后端的服务。
>* 半开状态:允许应用程序一定数量的请求去调用服务。如果调用程序，从半开到闭合，同时将错误计数器重置。如果调用失败数量达到要求，从半开到断开状态。

hystrix会在内存中维护一个数组，其中记录着每一个周期的请求结果的统计。超过时长长度的元素会被删除掉。

熔断设计的重点:
>* 错误的类型:根据错误类型不同的时候，进行不同的处理。
>* 日志监控:可以记录所有的失败请求。
>* 测试服务是否可用:在断开状态下，定期ping一下远程服务的健康检查接口，来判断服务是否恢复。
>* 手动重置:提供一个手动强制将断路器切换到闭合状态。
>* 并发问题:在高并发的情况，最好使用一些无锁结构，或是atomic的原子操作。
>* 资源分区:只对有问题的分区进行熔断，而不是整体。
>* 重试错误的请求:记录错误的请求，在半开状态下重试能够准确地直到服务是否真的恢复，接口是否支持幂等性。

## 限流设计
限流的策略:
>* 拒绝服务:把多出来的请求拒绝掉。
>* 服务降级:关闭或者把后端服务做降级处理。
>* 特权请求:资源不够了，只能把有限的资源分给重要的用户。
>* 延时处理:使用缓冲队列只是为了减缓压力，一般用于应对短暂的峰刺请求。
>* 弹性伸缩:动用自动化运维的方式对相应的服务做自动化的伸缩。

限流的实现方式:
>* 计数器方式:维护一个计数器counter，当一个请求过来，计数器增加1，请求处理完，计数器减1，如果计数器达到最大值，后来的请求就丢失。
>* 队列算法:一个有优先级的队列，处理时先处理高优先级的队列，然后在处理低优先级的队列。队列流控是以队列的方式来处理请求。
>* 漏斗算法:在队列上添加相应的限流器。以常量和很定的速度处理的。
>* 令牌桶算法:在桶里面放入token，处理程序处理请求时，需要拿到token，才能处理，否则不处理。流量小的时候攒钱，流量大的时候，可以快速处理。

漏斗算法和令牌桶算法都是受制于processor的最大处理能力。


## 降级设计

所谓的降级设计，本质是为了解决资源不足和访问量过大的问题。

降级需要牺牲掉的东西:
>* 降低一致性:从强一致性变成最终一致性(简化流程的一致性,将立即支付变成货到付款;降低数据的一致性,使用缓存的方式,或者直接去掉数据;)。
>* 停止次要功能:停止访问不重要的功能，从而释放更多的资源。
>* 简化功能:把一些功能简化掉。


## 弹力设计总结

架构中冗余服务,也就是说有多个服务的副本:
>* 负载均衡+服务健康检查-可以使用像nginx或haproxy这样的技术;
>* 服务发现+动态路由+服务健康检查，必须Consul或者Zookeeper;
>* 自动化运维,Kubernetes服务调度、伸缩和故障迁移。

隔离业务技术:
>* bulkheads模式:业务分片、用户分片、数据库分片。
>* 自包含系统:将一组密切相关的微服务拆分出来，只需要做到没有外部依赖就行。
>* 异步通讯:服务发现、事件驱动、消息队列、业务工作流。
>* 自动化运维:需要一个服务调用链和性能监控和监控系统。

容错技术:
>* 错误方面:调用重试+熔断+服务的幂等性设计。
>* 一致性方面:强一致性使用两阶段提交、最终一致性使用异步通讯方式。
>* 流控方面:使用限流+降级设计技术
>* 自动化运维方面:网关流量调度，服务监控。


WAR:非核心业务导致整个tomcat启动不起来。