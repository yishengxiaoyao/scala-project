# JVM内存区域和Java内存模型
## Java内存模型
### 主内存和工作内存
Java虚拟机规范中定义了Java内存模型(Java Memory Model,JMM),用于屏蔽各种硬件和操作系统之间的内存访问差异,以实现让Java程序在各种平台下都能达到一致的并发效果，JMM规范了Java虚拟机与计算机内存是如何协同工作的:规定了一个线程如何和何时可以看到由其他线程修改过后的共享变量的值，以及在必须时如何同步的访问共享变量。
原始的Java内存模型存在一些不足，因此Java内存模型在Java1.5时被重新修订。这个版本的Java内存模型在Java8中仍然在使用。
Java内存模型（不仅仅是JVM内存分区):调用栈和本地变量存放在线程栈上，对象存放在堆上。Java内存模型定义了线程与主内存之间的抽象关系:线程之间的共享变量存储在主内存中,每个线程都有一个私有的本地内存,本地内存中存储了该线程的读/写变量的副本。
Java的并发采用“共享内存”模型，线程之间通过读写内存的公共状态进行通讯。多个线程之间是不能通过直接传递数据交互的，它们之间交互只能通过共享变量实现。主要目的是定义程序中各个变量的访问规则。
JMM规定了所有的变量都存储在主内存（Main Memory）中。每个线程还有自己的工作内存（Working Memory）,线程的工作内存中保存了该线程使用到的变量的主内存的副本拷贝，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的变量（volatile变量仍然有工作内存的拷贝，但是由于它特殊的操作顺序性规定，所以看起来如同直接在主内存中读写访问一般）。不同的线程之间也无法直接访问对方工作内存中的变量，线程之间值的传递都需要通过主内存来完成。主内存主要对应Java堆中实例数据部分。工作内存对应于虚拟机栈中部分区域。

栈和堆存放数据的不同:
>* 一个本地变量可能是原始类型，在这种情况下，它总是“呆在”线程栈上。
>* 一个本地变量也可能是指向一个对象的一个引用。在这种情况下，引用（这个本地变量）存放在线程栈上，但是对象本身存放在堆上。
>* 一个对象可能包含方法，这些方法可能包含本地变量。这些本地变量仍然存放在线程栈上，即使这些方法所属的对象存放在堆上。
>* 一个对象的成员变量可能随着这个对象自身存放在堆上。不管这个成员变量是原始类型还是引用类型。
>* 静态成员变量跟随着类定义一起也存放在堆上。
>* 存放在堆上的对象可以被所有持有对这个对象引用的线程访问。当一个线程可以访问一个对象时，它也可以访问这个对象的成员变量。如果两个线程同时调用同一个对象上的同一个方法，它们将会都访问这个对象的成员变量，但是每一个线程都拥有这个成员变量的私有拷贝。


### Java线程之间的通讯由内存模型JMM控制
>* JMM决定一个线程对变量的写入何时对另一个线程可见。
>* 线程之间共享变量存储在主内存中
>* 每个线程有一个私有的本地内存，里面存储了读/写共享变量的副本。
>* JMM通过控制每个线程的本地内存之间的交互，来为程序员提供内存可见性保证。

### 内存间的交互
>* lock（锁定）：作用于主内存的变量，把一个变量标识为一条线程独占状态。
>* unlock（解锁）：作用于主内存的变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。
>* read（读取）：作用于主内存变量，把主内存的一个变量读取到工作内存中。
>* load（载入）：作用于工作内存，把read操作读取到工作内存的变量载入到工作内存的变量副本中
>* use（使用）：作用于工作内存的变量，把工作内存中的变量值传递给一个执行引擎。
>* assign（赋值）：作用于工作内存的变量。把执行引擎接收到的值赋值给工作内存的变量。
>* store（存储）：把工作内存的变量的值传递给主内存
>* write（写入）：把store操作的值入到主内存的变量中

注意在使用指令的时候需要满足下面的规则:
>* 不允许read、load、store、write操作之一单独出现
>* 不允许一个线程丢弃assgin操作
>* 不允许一个线程不经过assgin操作，就把工作内存中的值同步到主内存中
>* 一个新的变量只能在主内存中生成
>* 一个变量同一时刻只允许一条线程对其进行lock操作。但lock操作可以被同一条线程执行多次，只有执行相同次数的unlock操作，变量才会解锁
>* 如果对一个变量进行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或者assgin操作初始化变量的值。
>* 如果一个变量没有被锁定，不允许对其执行unlock操作，也不允许unlock一个被其他线程锁定的变量
>* 对一个变量执行unlock操作之前，需要将该变量同步回主内存中

### 三大特性:原子性、可见性和有序性
#### 原子性
一个操作不能被打断，要么全部执行完毕，要么不执行。在这点上有点类似于事务操作，要么全部执行成功，要么回退到执行该操作之前的状态。基本类型数据的访问大都是原子操作。

1.多线程与原子性
解决问题的方式:使用同步代码块、Java内存模型提供了lock和unlock操作来满足这种需求。虚拟机提供了字节码指令monitorenter和monitorexist来隐式地使用这两个操作，这两个字节码指令反映到Java代码中就是同步快——synchronized关键字。


#### 可见性
一个线程对共享变量做了修改之后，其他的线程立即能够看到（感知到）该变量这种修改（变化）。
Java内存模型是通过将在工作内存中的变量修改后的值同步到主内存，在读取变量前从主内存刷新最新值到工作内存中，这种依赖主内存的方式来实现可见性的。

1.多线程读同步与可见性
线程缓存导致的可见性问题:
如果两个或者更多的线程在没有正确的使用volatile声明或者同步的情况下共享一个对象,在修改之后，CPU缓存没有刷新到主内存中,对象修改之后的版本对其他跑在其他CPU线程上的线程都是不可见的。这种方式导致每个线程拥有这个共享对象的私有拷贝,每个拷贝都停留在不同的CPU缓存中。
解决方法:
>* 正确使用volatile关键字:Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式来实现可见性的。普通变量与volatile变量的区别是：volatile的特殊规则保证了新值能立即同步到主内存，以及每个线程在每次使用volatile变量前都立即从主内存刷新。
>* synchronized关键字:同步块的可见性是由“如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前需要重新执行load或assign操作初始化变量的值”、“对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store和write操作）”这两条规则获得的。
>* final关键字:被final修饰的字段在构造器中一旦被初始化完成，并且构造器没有把“this”的引用传递出去（this引用逃逸是一件很危险的事情，其他线程有可能通过这个引用访问到“初始化了一半”的对象），那么在其他线程就能看见final字段的值（无须同步）。

2. 指令冲排序导致的可见性问题
解决方法:可以使用volatile禁止指令重排序;使用synchronized来进行加锁保证互斥操作的顺序

指令序列的排序分为:编译器优化的重排序;指令级优化的重排序;内存系统的重排序


#### 有序性
在本线程内观察，操作都是有序的；如果在一个线程中观察另外一个线程，所有的操作都是无序的。前半句是指“线程内表现为串行语义（WithIn Thread As-if-Serial Semantics）”,后半句是指“指令重排”现象和“工作内存和主内存同步延迟”现象。
Java提供了两个关键字volatile和synchronized来保证多线程之间操作的有序性,volatile关键字本身通过加入内存屏障来禁止指令的重排序，而synchronized关键字通过一个变量在同一时间只允许有一个线程对其进行加锁的规则来实现。
在单线程程序中，不会发生“指令重排”和“工作内存和主内存同步延迟”现象，只在多线程程序中出现。

### happen-before原则
与程序员密切相关的happens-before规则如下：

>* 程序顺序规则：一个线程中的每个操作，happens-before于该线程中任意的后续操作。
>* 监视器锁规则：对一个锁的解锁操作，happens-before于随后对这个锁的加锁操作。
>* volatile域规则：对一个volatile域的写操作，happens-before于任意线程后续对这个volatile域的读。
>* 传递性规则：如果 A happens-before B，且 B happens-before C，那么A happens-before C。


## 硬件内存架构
现代硬件内存模型与Java内存模型有一些不同，理解内存模型架构以及Java内存模型如何与它协同工作也是非常重要的。

### 多CPU
一个现代计算机通常由两个或者多个CPU。其中一些CPU还有多核。从这一点可以看出，在一个有两个或者多个CPU的现代计算机上同时运行多个线程是可能的。每个CPU在某一时刻运行一个线程是没有问题的。这意味着，如果你的Java程序是多线程的，在你的Java程序中每个CPU上一个线程可能同时（并发）执行。

### CPU寄存器
每个CPU都包含一系列的寄存器，它们是CPU内内存的基础。CPU在寄存器上执行操作的速度远大于在主存上执行的速度。这是因为CPU访问寄存器的速度远大于主存。

### 高速缓存cache
由于计算机的存储设备与处理器的运算速度之间有着几个数量级的差距，所以现代计算机系统都不得不加入一层读写速度尽可能接近处理器运算速度的高速缓存（Cache）来作为内存与处理器之间的缓冲：将运算需要使用到的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步回内存之中，这样处理器就无须等待缓慢的内存读写了。CPU访问缓存层的速度快于访问主存的速度，但通常比访问内部寄存器的速度还要慢一点。每个CPU可能有一个CPU缓存层，一些CPU还有多层缓存。在某一时刻，一个或者多个缓存行（cache lines）可能被读到缓存，一个或者多个缓存行可能再被刷新回主存。
### 内存
一个计算机还包含一个主存。所有的CPU都可以访问主存。主存通常比CPU中的缓存大得多。
### 运作原理
通常情况下，当一个CPU需要读取主存时，它会将主存的部分读到CPU缓存中。它甚至可能将缓存中的部分内容读到它的内部寄存器中，然后在寄存器中执行操作。当CPU需要将结果写回到主存中去时，它会将内部寄存器的值刷新到缓存中，然后在某个时间点将值刷新回主存。

### 硬件内存架构带来的问题
####缓存一致性问题
在多处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主内存（MainMemory）。基于高速缓存的存储交互很好地解决了处理器与内存的速度矛盾，但是也引入了新的问题：缓存一致性（CacheCoherence）。当多个处理器的运算任务都涉及同一块主内存区域时，将可能导致各自的缓存数据不一致的情况，如果真的发生这种情况，那同步回到主内存时以谁的缓存数据为准呢？为了解决一致性的问题，需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议来进行操作，这类协议有MSI、MESI（IllinoisProtocol）、MOSI、Synapse、Firefly及DragonProtocol等等。

#### 指令重排序问题
为了使得处理器内部的运算单元能尽量被充分利用，处理器可能会对输入代码进行乱序执行（Out-Of-Order Execution）优化，处理器会在计算之后将乱序执行的结果重组，保证该结果与顺序执行的结果是一致的，但并不保证程序中各个语句计算的先后顺序与输入代码中的顺序一致。因此，如果存在一个计算任务依赖另一个计算任务的中间结果，那么其顺序性并不能靠代码的先后顺序来保证。与处理器的乱序执行优化类似，Java虚拟机的即时编译器中也有类似的指令重排序（Instruction Reorder）优化


## Java内存模型和硬件内存架构之间的桥接
Java内存模型与硬件内存架构之间存在差异。硬件内存架构没有区分线程栈和堆。对于硬件，所有的线程栈和堆都分布在主内存中。部分线程栈和堆可能有时候会出现在CPU缓存中和CPU内部的寄存器中。

从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：

>* 线程之间的共享变量存储在主内存（Main Memory）中
>* 每个线程都有一个私有的本地内存（Local Memory），本地内存是JMM的一个抽象概念，并不真实存在，它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。本地内存中存储了该线程以读/写共享变量的拷贝副本。
>* 从更低的层次来说，主内存就是硬件的内存，而为了获取更好的运行速度，虚拟机及硬件系统可能会让工作内存优先存储于寄存器和高速缓存中。
>* Java内存模型中的线程的工作内存（working memory）是cpu的寄存器和高速缓存的抽象描述。而JVM的静态内存储模型（JVM内存模型）只是一种对内存的物理划分而已，它只局限在内存，而且只局限在JVM的内存。


## 参考文献
[Java内存模型（JMM）总结](https://zhuanlan.zhihu.com/p/29881777)
[全面理解Java内存模型](https://blog.csdn.net/suifeng3051/article/details/52611310)
[Java内存模型和JVM内存管理](https://www.cnblogs.com/yjd_hycf_space/p/7505372.html)
[JVM 完整深入解析](https://segmentfault.com/a/1190000014395186)