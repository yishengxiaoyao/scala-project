# 数据结构与算法之美
## 数组:为什么很多编程语言中数据都是从0开始
>* 数组是一种线性表的数据结构。它是一组连续的内存结构，来存储一组具有相同类型的数据。
>* 线性表就是数据排成一条线一样的数据，每个线性表上的数据最多只有前和后两个方向。
>* 数组、链表、队列、栈都是线性表结构。二叉树、堆、图都是非线性表结构。
>* 连续的内存空间和相同类型的数据:随机访问。删除和插入操作，就需要做大量的数据搬移工作。
>* 随机访问:一维数组寻找公式:a[k] = base_address + k * data_type_size;二维数组寻找公式:a[i][j]=base_address + (i * n + j) * data_type_size
>* 数组支持随机访问，根据下标随机访问的时间复杂度为O(1),开头插入:最坏时间复杂度为O(n),平均情况时间复杂度是O(n);在中间第K位插入,
时间复杂度为O(1),在末尾插入的时间复杂度为O(1);在开头删除:最坏时间复杂度是O(n),平均时间复杂度为O(n);在中间第K位删除:
每次删除操作只是记录数据已经被删除,当没有更多空间时，才触发执行真正的删除操作;在末尾删除:最好的时间复杂度为O(1)。
插入、删除操作的平均时间复杂度为O(n)。
ArrayList是将数组操作的细节封装起来，并且可以动态扩容(自动扩大1.5倍)。
ArrayList无法存储基本类型。

JVM标记清除算法:在标记阶段，会遍历所有GC ROOTS，
将所有GC ROOTS可达的对象标记为存活，只有当标记工作完成后，
清理工作才会开始。

不足:1.效率问题:标记和清理效率都不高,当少量垃圾产生时会很高效;2.空间问题:会产生不连续的内存空间碎片。

数组访问越界造成无限循环,是编译器的问题。如果内存地址递减的方式，就会造成无限循环。

## 链表
缓存是一种提高数据读取性能的技术。
缓存的大小有限,当缓存满的时候,需要将不需要的数据清除掉。常见的策略有三种:先进先出策略FIFO、最少使用策略(LFU)、最近最少使用策略(LRU)。
链表不需要一块连续的内存空间,通过指针将一组零散的内存块串联起来使用。

数组简单易用,使用连续的内存空间,借助CPU的缓存机制,可以预读数据,所以访问效率更高。
链表在内存中并不是连续存储,对CPU缓存不友好,没方法有效预读。

数据的缺点是大小固定,如果过大,会导致内存不足,如果过小,需要扩容,将数据拷贝到新的数组中,非常耗时。
链表没有大小的限制,天然地支持动态扩容。

链表:通过指针将一组零散的内存块串联起来使用;插入、删除数据非常快速。

单链表:
>* 查找:通过指针一个节点一个节点地一次遍历,知道找到相应的节点;插入、删除数据都非常快速。
>* 插入和删除:只需要考虑相邻节点的指针改变;时间复杂度为O(1)。

循环链表:
>* 概念:一种特殊的单链表;尾指针指向头节点。

双向链表:
>* 概念:支持两个方向,有一个后继指针next指向后面节点,一个前驱指针prev指向前面的节点。查找、删除和插入的效率都比单链表高。
>* 删除等于某个值的节点:从头节点依次遍历对比,直到找到等于给定制的节点，通过指针删除;时间复杂度为O(n)。
>* 删除给定指针指向的节点:遍历节点,找到前驱节点，然后删除，时间复杂度为O(1)。

## 栈
栈是一种操作受限的线性表,只允许在一端插入和删除操作,后进者先出,先进者后出。

入栈和出栈:时间复杂度为O(1),空间复杂度为O(1)。

栈支持动态扩容:
>* 实现:底层依赖一个动态扩容的数组;当栈满了之后,就申请一个更大的数组,将原来的数组搬移到新的数组中。
>* 入栈:最好的情况时间复杂度为O(1);最坏情况时间复杂度为O(n);均摊时间复杂度为O(1)。
>* 出栈:时间复杂度为O(1)。


## 队列

队列是一种操作受限的线性表结构,先进者先出。
实现:需要两个指针,head指针,指向对头;tail指针,指向队尾;

|队列分类|实现方式|
|----|----|
|顺序队列|1.用数组实现队列;2.出对时不能搬移数据,如果没有空闲空间,只需要在入队时在集中触发一次数据的搬移操作|
|链式队列|用链表实现队列|
|循环队列|1.把数组首尾相连,组成一个环;2.确定好对空和队满的判定条件,队列为空的判断条件为head == tail,队满时(tail+1)%n==head;3.缺点:队列满时,tail指向的位置没有存储数据,循环队列会浪费一个数组的存储空间|
|阻塞队列|1.在队列基础上增加了阻塞操作;2.在队列为空的时候，从对头读取数据会被阻塞。|
|并发队列|1.线程安全的队列;2.实现:方式1,直接在enqueue、dequeue上加锁,锁力度大并发度会比较低,同一时刻仅允许一个存或者取操作;方式2,利用CAS原子操作,可以实现非常高效的并发实现|

LinkedHashMap的底层实现为双向链表。
LinkedList的底层实现为双向链表。

## 递归

递归的优点:代码的表达力很强，写起来简洁。
递归的缺点:空间复杂度高、有堆栈溢出风险、存在重复计算、过多的函数调用会耗时较长等问题。

递归需要满足的三个条件:
>* 一个问题的解可以分解为几个子问题的解。
>* 这个问题与分解之后的子问题,除了数据规模不同，求解思路完全一样。
>* 存在递归终止条件。

写递归代码的关键就是找到如何将大问题分解为小问题的规律,并且给予此写出递推公式,然后在推敲终止条件,最后将递推公式和终止条件翻译成代码。

递归代码需要注意的问题:
>* 递归代码要警惕堆栈溢出:如果递归很深,可能会出现堆栈溢出的问题;如果数据库中存在脏数据,需要处理由此产生无限递归问题。
>* 递归代码要警惕重复计算:可以将一些计算出来的数据存储起来。

## 排序
如何分析一个排序算法？
>* 最好情况、最坏情况、平均情况复杂度
>* 时间复杂度的系数、常数、低阶
>* 比较次数和交换次数:1.排序算法的内存消耗:可以通过空间复杂度来衡量,原地排序算法是指空间复杂度为O(1)的排序算法;2.排序算法的稳定性:稳定性是指如果待排序的序列中存在相等的元素,经过排序之后,相等元素之间原有的先后顺序不变。

### 冒泡排序
冒泡排序只会操作相邻的两个数据。

冒泡排序是原地排序算法(只设计相邻数据的交换操作,使用临时空间)、是稳定的排序算法(只交换两个不想等元素的问题)、时间复杂度为(最好情况为O(n),最坏情况为O(n^2))。

有序度是数组中具有有序关系的元素对的个数。有序元素对用数学表达式:a[i]<=a[j],如果i < j。
逆序度的逻辑:a[i]>a[j],如果i < j;
数组的满有序度为n(n-1)/2。

逆序度 = 满有序度 - 有序度。


### 插入排序










