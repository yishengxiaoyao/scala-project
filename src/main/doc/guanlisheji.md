# 管理设计
## 分布式锁
分布式锁的特点:
>* 安全性:在任意时刻，只有一个客户端可以获得锁(排他性)。
>* 避免死锁:客户端最终一定可以获得锁，即使锁往某个资源的客户端在释放锁之前崩溃或者网络不可达。
>* 容错性:只要锁服务集群中的大部分节点存活，Client就可以进行加锁解锁操作。

### Redis分布式锁服务
```
SET resource_name my_random_value NX PX 30000
```
只有在某个key不存在的情况下才能设置成功该key。
```
if redis.call("get",KEYS[1]) == ARGV[1] then
    return redis.call("del",KEYS[1])
else
    return 0
end
```
如果key对应的value一致，则删除这个key(客户端的解锁操作只会解锁自己曾经加锁的资源，是安全的)。

### 分布式锁服务的一个问题
如果在分布式环境中，上面redis的操作，就会有问题。需要引入fence来解决这个问题，就是乐观锁机制，需要一个版本号排他。
如果使用Zookeeper做锁服务的话，使用zxid或者znode的版本号来做这个fence的版本号。

### 从乐观锁到CAS
没更新一次，version就加1。数据库中大多数用的是时间戳。

### 分布式锁设计的重点
分布式锁的特点是:保证在一个集群中，同一个方法在同一时间只能被一台机器上的一个线程执行。

>* 获取锁的进程挂掉了怎么办？在锁服务上添加一个过期时间，如果在这个时间内锁没有被还回来，锁服务自动解锁，以避免全部锁住。

设计分布式锁服务，需要考虑的问题:
>* 需要给一个锁被释放的方式，以避免请求不把锁换回去，导致死锁的问题。Redis使用超时时间，Zookeeper可以依靠自身的sessiontimeout来射出节点。
>* 分布式锁服务应该是高可用的，并且是需要持久化的。
>* 提供分阻塞方式的锁服务。
>* 考虑锁的可重入性。

## 配置中心
### 区分软件的配置
软件的配置分为静态配置(在软件启动时的一些配置，运行时不会进行修改)和动态配置(按照环境分、按照依赖分、按层次分)。

### 配置中心的架构
>* 为什么需要一个变更通知的组件，而不是让配置中心直接推送？原因是分布式环境下，服务器太多，推送不太现实，而采用一个Pub/Sub的通知服务可以让那个数据交换经济一些。
>* 为什么不直接Pub数据过去，还要订阅方反向拉数据？直接推送数据当然可以，使用API来访问的好处:鉴权、调用配置中心的基本API。
>* 配置变更控制器部署在哪里？是在服务器上，还是一个中心的地方？变更配置是一个事务，建议配置变更放在每一台机器上。
>* 平台层的配置变更，有的参数是在服务启动的命令行上，这个怎么变更？一般通过shell做成配置项，通过更新系统环境变量，并重启服务达到配置变更。
>* 操作系统的配置变更和平台层的配置变更最好模块化:有利于维护和减少配置的复杂性。
>* 应用服务配置更新的标准化:通过一个开发框架或者SDK的方式来解决(开发规范，耦合语言);标准运维脚本，让应用方提供变更时的脚本动作；


## 边车模式

边车来实现这些与业务逻辑没有关系的控制功能。

编程的本质就是将控制和逻辑分离和耦合，而边车模式也是异曲同工。

在工程实现sidecar的时候，需要注意一下几个方面:
>* 进程间通讯机制是这个设计的重点，最好使用网络远程调用的方式。

## 服务网格

Service Mesh这个服务网格专注于处理服务和服务间的通讯。其主要负责构造一个稳定可靠的服务通讯的基础设置，并让整个架构更为先进。
>* Service Mesh是一个基础设施。
>* Service Mesh 是一个轻量的服务通讯的网络代理。
>* Service Mesh 对于应用服务来说是透明无入侵的。
>* Service Mesh 用于解耦和分离分布式关系架构中控制层面的东西。

Istio是目前最主流的解决方案，其核心的sidecar被叫做envoy，用来协调服务网格中所有服务的出入站流量，并提供服务发现、负载均衡、限流熔断等能力，还可以收集大量与流量相关的性能指标。
在Service Mesh控制面上，有一个叫Mixer的收集器，用来从Envoy收集相关的被监控到的流量特征和性能指标。
然后，通过Pilot的控制器将相关的规则发送到Envoy中，让Envoy应用新的规则。

为安全设计的Istio-Auth身份认证组件，用来做服务间的访问安全控制。

Kubernetes和Docker对于应用服务的干扰是比较少。Kubernetes和Docker的服务进程的失败不会导致应用服务的异常运行。
Service Mesh如果有问题，会导致整个架构出现致命的问题。

Service Mesh不像sidecar需要和serivce一起打包一起部署，Service Mesh完全独立部署。

## 网关模式
Sidecar和Service Mesh都是在不侵入业务逻辑的情况下，把控制面和数据面的处理解耦分离。

网关需要的功能:请求路由、服务注册、负载均衡、弹力设计、安全方面、灰度发布、API聚合、API编排。

Servicecar的方式主要是用来改造已有的服务。Siddecar适配应用服务，成为应用服务进出请求的代理。
Servicecar数量多之后，需要使用Service Mesh来统一管理Servicecar。Servicecar的粒度应该是可粗可细的，这样更为方便。Gateway只负责进入的请求。

网关设计的重点：高性能、高可用(集群化、服务化、持续化)、运维方面(业务松耦合，协议紧耦合;应用监视，提供分析数据；用弹力设计保护后端服务;Devops)、架构方面(不要在网关中的代码里内置聚合后端服务的功能;网关应该和后端服务离的很近，减少延迟;容量扩展;服务发现做缓存;做bulkload设计)、安全方面(加密数据、校验用户的请求、检测异常访问)。

## 部署升级策略

服务部署的模式:
>* 停机部署:把现有的版本的服务停机，然后部署新的版本。
>* 蓝绿部署:部署好新的版本后，把流量从老服务那边切过来。
>* 滚动部署:一点一点地升级现有的服务。
>* 灰度部署:把一部分用户切到新版本上来，然后看一下有没有问题，如果是没有问题，扩大升级。
>* AB测试:同时上线了两个版本，然后做相关的比较。

| |概念|优点|缺点||
|----|----|----|---|
|停机部署|把现有版本的全部停掉,部署新的版本|不会出现新老版本同时在线的情况,所有状态完全一致|停机,对用户的影响很大|
|蓝绿部署|部署相同数量的新服务,把流量且过来|无需停机,实时发布和升级,避免有新旧版本同时在线的问题|使用双倍资源|
|滚动部署|逐个替换应用的所有实例|便于操作|用户请求会到新老版本,导致问题;回滚有问题;有兼容性问题|
|灰度部署|流量逐渐从旧版本切换到新版本|看用户在新版本是否有问题|缺少足够测试|
|AB测试|同时上线两个版本,然后做比较|测试服务|消耗资源|

蓝绿部署是为了不停机,灰度部署是对新版本的质量没信心,AB测试是对新版本的功能没信心。

对于灰度或者AB测试，可以选择下面的参数为依据:浏览器cookies、查询参数、地理位置、技术支持、客户端语言。

|策略|不停机|网关流量|用户采样|成本|回滚时长|复杂度|
|----|----|----|----|----|----|----|
|停机|False|False|False|低|长|低|
|蓝绿|True|False|False|中|短|中|
|滚动|True|False|False|低|长|低|
|灰度|True|True|False|中|一般|中|
|AB|True|True|True|高|一般|高|