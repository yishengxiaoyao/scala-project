# Java代码是如何运行的

## 为什么Java要在虚拟机里运行
JRE:Java的运行时环境。
JRE仅包含运行Java程序的必须组件,包括Java虚拟机以及Java核心类库等。
Java虚拟机是将Java代码转换为字节码。
Java虚拟机可以有硬件实现,也可以用软件实现。使用软件实现的好处,一旦一个程序被转换为Java字节码,那么它便可以在不同平台上的虚拟机实现里运行。
虚拟机的另外一个好处:托管环境,自动内存管理与垃圾回收。

## Java虚拟机具体是怎样运行Java字节码

### 虚拟机
从虚拟机的角度来看,执行Java代码首先需要将它编译而成的class文件加载到java虚拟机中。
加载后的Java类会被存放于方法区。实际运行时,虚拟机会执行方法区内的代码。
Java虚拟机在内存中划分出堆和栈来存储运行时数据。Java虚拟机会将栈细分为面向Java方法的Java方法栈(存放局部变量以及字节码的操作数)、
面向本地方法栈、以及存放各个线程执行位置的PC寄存器。

从硬件角度来看,Java虚拟机需要将字节码翻译成机器码。
解释执行:即逐条将字节码翻译成机器码并执行(无需等待编译)。即时编译:即将一个方法中包含的所有字节码编译成机器码后在执行(实际运行速度更快)。
HotSpot默认采用混合模式,先解释执行字节码,而后将其中反复执行的热点代码,以方法为单位进行即时编译。

## Java虚拟机的运行效率是怎么样的

HotSpot提供了C1、C2和Graal(Java10)编译器。

C1又叫做Client编译器,面向的是对启动性能有要求的客户端GUI程序,采用的优化手段相对简单,因此编译时间较短。
C2又叫做Server编译器,面向的是对峰值性能又要求的服务端程序，采用的优化手段相对复杂,因此编译时间较长。

从Java7开始,HotSpot默认采用分层编译的方式:热点方法会先被C1编译,而后热点方法中的热点会进一步被C2编译。
HotSpot的即时编译是放在额外的编译线程中进行的。HotSpot会根据CPU的数量设置编译线程的数目,并且按1:2的比例
配置为C1和C2编译器。

Java虚拟机会将boolean类型看作是int类型。true就是1,false是0。


|类型|值域|默认值|虚拟机内部符号|
|----|----|----|----|
|boolean|{false,true}|false|Z|
|byte|[-128,127]|0|B|
|short|[-32768,32767]|0|S|
|char|[0,65535]|'\u0000'|C|
|int|[-2^31,2^31-1]|0|I|
|long|[-2^63,2^63-1]|0L|J|
|float|~[-3.4E38,3.4E38]|+0.0F|F|
|double|~[1.8E308,1.8E308]|+0.0D|D|

不管何种类型,拥有不同的值域,但默认值在内存中均为0。

声明为byte、char以及short的局部变量,是可以存储超过它们取值范围的数值,在存储的时候,Java虚拟机会进行掩码操作。
在读取时,Java虚拟机则会将其扩展为int类型。

将boolean保存在静态域中,制定了其类型为'Z',当修改为2时取低位最后一位为0,当修改为3时取低位最后一位为1。
说明boolean的掩码处理是取低位的最后一位。



## Java虚拟机是如何加载Java类

Java语言的类型可以分为两大类:基本类型和引用类型。Java将其细分为四种:类、接口、数组类和泛型参数。由于泛型参数会在编译过程中被擦除。
在类、接口和数组类中,数组类是由Java虚拟机直接生成的,其他两种则有对应的字节流。

### 加载
加载是指查找字节流,并且据此创建类的过程。对于数组类来说,它并没有对应的字节流,而是Java虚拟机直接生成的。对于其他的类来说,
Java虚拟机则需要借助类加载起来完成查找字节流的过程。

启动类加载(Bootstrap Loader)是由C++实现的,没有对应的Java对象,因此在Java中只能用null来替代。
除了Bootstrap Loader之外,其他的类加载器都是java.lang.ClassLoader的子类,因为有对应的Java对象。这些类加载器需要先有
Bootstrap Loader,加载至Java虚拟机中,方能执行类加载。

JVM使用的是双亲委派模型:每当一个类加载接收到加载请求时,它会将请求转发给父类加载器。在父类加载器没有找到所请求的类的情况下,该类
加载器才会尝试取加载。

Java 9 之前,Bootstrap Loader负责加载最为基础、最为重要的类(jre/lib/rt.jar的类);
ExtClassLoader负责加载扩展类(jar/lib/ext/*.jar的类);AppClassLoader负责加载应用类(classpath制定的目录或jar中的类)。

类的加载方式分为隐士加载和显示加载。隐士加载指的是程序在使用new等方式创建对象时,会隐士地调用类的加载器把对应的类加载到JVM中。
显示加载指的是通过直接调用Class.forName()方法来把所需的类加载到JVM中。

Java语言中,类的加载是动态的,它并不会一次性将所有类全部加载后再运行,而是保证程序运行的基础类完全加载到JVM中,至于其他类,在需要时才加载。

在Java虚拟机中,类的唯一性是由类加载器实例以及类的全名一同确定,即便是同一串字节流,经由不同的类加载器加载,也会得到两个不同的类。

### 链接
链接是指将创建成的类合并至Java虚拟机中,使之能够执行的过程。可以分为验证、准备以及解析三个阶段。

验证阶段的目的,在于确保被加载类能够满足Java虚拟机的约束条件。

准备阶段的目的,则是为被加载类的静态字段分配内存。

解析阶段的目的,将这些符号引用解析成为实际引用。如果符号引用指向一个未被加载的类,或者未被加载的字段或方法,那么解析将触发这个类的加载。

Java虚拟机规范并没有要求在链接过程中完成解析。

### 初始化

在Java代码中,如果要初始化一个静态字段,可以声明时直接赋值,也可以在静态代码块中对其赋值。
如果直接赋值的静态字段被final所修饰,并且它的类型是基本类型或字符串时,那么该字段便会被Java编译器标记成常量值,
其初始化直接由Java虚拟机完成。除此之外的直接赋值操作,所以所有静态代码块中的代码,则会被Java编译器置于同一方法中,并把它命名为<clinit>。
类加载的最后一步是初始化,便是为标记为常量值的字段赋值,以及执行<clinit>方法的过程。Java虚拟机会通过加锁来确保类的<clinit>方法仅被执行一次。

那种方式可以触发初始化:
>* 当虚拟机启动时,初始化用户制定的主类;
>* 当遇到用以新建目标类实例的new指令时,初始化new指令的目标类;
>* 当遇到调用静态方法的指令时,初始化该静态方法所在的类;
>* 当遇到访问静态字段的指令时,初始化该静态字段所在的类;
>* 子类的初始化会触发父类的初始化;
>* 如果一个接口定义了default方法,那么直接实现或者间接实现该接口的类的初始化,会触发该接口的初始化;
>* 使用反射API对莫个类进行反射调用时,初始化这个类;
>* 当初次调用MethodHandle实例时,初始化该MethodHandle指向的方法所在的类。

由于类初始化是线程安全的,并且仅按被执行一次,因此程序可以确保多线程环境下有且仅有一个Singleton实例。

在创建对象时,不会初始化元素;在调用时,才会真正链接和初始化。

## JVM是如何执行方法调用的

如果想要在同一个类中定义名字相同的方法,他们的参数类型必须不同，这些方法之间的关系,称之为重载。

选取的步骤:
>* 在不考虑对基本类型自动装拆箱，以及可变长参数的情况下选择重载方法。
>* 如果第一个阶段中没有找到适配的方法,那么在允许自动装拆箱，但不允许可变参数的情况下选取重载方法。
>* 如果在第二阶段中没有找到相应的适配方法,那么允许自动装拆箱以及可变长参数的情况下选择重载方法。

如果子类定义了与父类中非私有方法同名的方法,而且两个方法的参数类型不同, 那么在子类中,这两个方法同样构成了重载。
如果两个方法都是静态的,那么子类中的方法隐藏了弗雷中的方法。如果两个方法都不是静态的,且都不是私有的，那么子类的方法重写了父类中方法。

### JVM的静态绑定与动态绑定

Java虚拟机识别方法的关键在于类名、方法名以及方法描述符。

Java虚拟机与Java语言不同,它并不限制名字与桉树类型相同,但是返回类型不同的方法出现在同一个类中，对于调用这些方法的字节码来说,由于字节码所附带的方法描述包含了返回类型,
因此Java虚拟机能够准确地识别目标方法。

Java虚拟机中的静态绑定是指在解析时更能够直接识别目标方法的情况,动态绑定则指的是需要在运行过程中根据调用者的动态类型来识别目标方法的情况。

Java字节码中与调用相关的指令有5种:
>* invokestatic:用于调用静态方法。
>* invokespecial:用于调用私有实例方法、构造器,以及使用super关键字调用父类的实例方法或构造器,和实现接口的默认方法。
>* invokevirtual:用于调用非私有实例方法。
>* invokeinterface:用于调用接口方法.
>* invokedynamic：用于动态方法。

唯一例外的在于,如果虚拟机能够确定目标方法有且仅有一个,，那么它可以不通过动态类型，直接确定目标方法。

### 调用指令的符号引用


invokevirtual和invokeinterface指令,都属于java虚拟机中的虚方法调用。
如果有的目标放啊被标记为final,那么Java虚拟机采用静态绑定。

Java虚拟机中,静态绑定包括用于调用静态方法的invokestatic指令,和用于调用构造器、私有实例方法以及超类非私有实例方法的invokespecial指令。

Java虚拟机实现动态绑定的关键是使用虚方法表、接口方法表。方法表本质是一个数组，每个数组元素指向一个当前类机器祖先类中非私有的实例方法。
方法表必须满足两个特质:子类方法表中包含子类方法表中的所有方法；子类方法在方法表中的索引值,与它所重写的父类方法的索引值相同。


对于静态方法调用而言,实际引用是将指向具体的目标方法，对于动态绑定的方法调用而言,实际引用则是方法表的索引值。

即时编译有两种性能更好的优化方法:内联缓存和方法内联。

内联缓存是一种加快动态绑定的优化技术，它能够缓存虚方法调用中调用者的动态类型,以及该类型所对应的目标方法。在之后的执行过程中,
如果碰到已经缓存的类型,内联缓存便会直接调用该类型所对应的目标方法。如果没有找到，从方法表中查找。

动态优化的方法:
>* 单态指的是仅有一种状态的情况。
>* 多态指的是有限数量种状态的情况。
>* 超多态:更多中状态的情况。

单态内联缓存便只缓存一种动态类型以及它所对应的目标方法，比较所缓存的动态类型,如果命中，直接调用对应的目标方法。
多态内联缓存则缓存了多个动态类型以及目标方法。逐个将所缓存的动态类型与当前类型进行比较，如果命中，直接调用对应的目标方法。


## JVM是如何处理异常

异常处理的靓噶组成要素是抛出异常和捕获异常。这两大要素共同实现程序控制流的非正常转移。

抛出异常可分为显示和隐式两种。显示抛出的主体是应用程序,它指的是在程序中使用throw关键字,手动将异常实例抛出。

隐式抛出异常的主体则是Java虚拟机,它指的是Java虚拟机在执行过程中，碰到无法执行的异常状态,自动抛出异常。

捕获异常则涉及如下三种代码块:
>* try代码块:用来标记需要进行异常监控的代码。
>* catch代码块:跟在try代码块之后,用来补货在try代码中触发的某种指定类型的异常。除了声明所捕获异常的类型之外,catch代码块还定义了针对该异常类型的异常处理器。try代码块后面可以跟多个catch代码块。
>* finally代码块:跟在try代码块和catch代码块之后，用来声明一段必定运行的代码。

### 异常的基本概念
在Java语言规范中，所有的异常都是Throwable类或者子类的实例。Throwable有两大直接子类。第一个是Error,涵盖沉痼不应捕获的异常。当触发Error的时候，只能终止线程或者终止虚拟机。
第二个是Exception，涵盖程序可能需要捕获并处理的异常。

RunntimeException和Error属于Java里的非检查异常。其他异常则是属于检查异常。

异常实例的构造十分昂贵。在构造异常实例时，Java虚拟机便需要生成该异常的栈轨迹,该操作会逐一访问当前线程的Java栈帧，并且记录下各种调试信息，包括栈帧所指向方法的名字，方法所在的类名、文件名，以及在代码中第几行触发异常。

### Java虚拟机是如何捕获异常的
在编译生成的字节码中，每个方法都附带一个异常表。异常表中的每一个条目代表一个异常处理器，并且由from指针、to指针、target指针以及所捕获的异常类型构成。这些指针的值是字节码索引，用于定位字节码。
其中，from指针和to指针标识了该异常处理器所监控的范围。target指针则执行异常处理器的起始位置。

当程序触发异常时,Java虚拟机会从上至下遍历异常表中的所有条目，进行匹配。如果匹配,Java虚拟机将控制流转移至该条目target指针指向的字节码。如果不匹配，在调用者中重复上述操作。

finally代码块的编译比较复杂。

### Java 7的Suppressed异常以及语法糖

如果在catch中再次出现异常:需要使用Java 7 中的Suppressed异常来解决这个问题。

Java 7专门构造一个名为try-with-resources的语法糖,在字节码层面自动使用Suppressed异常。当然,该语法糖的主要目的并不是使用Suppressed异常,而是精简资源打开关闭的用法。

Java 7的try-with-resources语法糖,极大地简化了异常代码。程序可以在try关键字后声明并实例化实现AutoCloseable接口的类,编译器将自动添加对应的close()操作。在声明多个
AutoCloseable实例的情况下，编译生成的字节码类似于手动编写代码的编译结果。

Java 7还支持在同一catch代码块中捕获多种异常。


## JVM是如何实现反射
反射在日常生活中应用十分广泛.IDEA中的代码提示功能;Java调试器。反射开销比较大。
```
public final class Method extends Executable{
	public Object invoke(Object obj,Object... args)throw ...{
		//权限检查
		MethodAccessor ma = methodAccessor;
		if (ma == null){
			ma = acquireMethodAccessor();
		}
		return ma.invoke(obj,args);
	}
	
}
```
MethodAccessor是一个接口,它由两个已有的具体实现:一个通过本地方法来实现反射调用,另一个则使用了委派模型。
每个Method实现的第一个反射都会生成一个委派实现,它所委派的具体实现便是一个本地实现。

反射调用为什么还要采取委派实现作为中间层？直接交给本地实现不可以吗？
Java的反射调用机制还设立了另一种动态生成字节码的实现,直接使用invoke指令来调用目标方法。
之所以采用委派实现,便是为了能够在本地实现以及动态实现中切换。动态实现和本地实现相比,其运行效率快。这是因为动态实现
无需经过Java到C++再到Java的切换,但由于生成字节码十分耗时。仅调用一次的化,反而是本地实现要快上3到4倍。

-Dsun.reflect.inflationThreshold=15 当某个反射的调用次数小于15时,采用本地实现;达到15时,动态生成字节码，并将委派
实现的委派对象切换至动态实现。这个过程称之为inflation。
-Dsun.reflect.noinflation=true，来关闭inflation,反射的时候直接动态实现,不会使用委派实现或者本地实现。

Class.forName会调用本地方法。Class.getMethod会遍历该类的公有方法，如果没有匹配的，遍历父类的公有方法。
为了避免热点使用getMethods或者getDeclaredMethods。

在默认情况下,方法的反射调用为委派实现,委派给本地实现来进行方法调用。在调用超过15次之后,委派实现便会将委派对象
切换至动态实现。这个动态实现的字节码是自动生成的，它将直接使用invoke指令来调用目标方法。

方法反射调用会带来不少性能开销,原因如下:
>* 变长参数方法导致的Object数组，基本类型的自动封箱、拆箱，还有最重要的方法内联。











